import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError, map } from 'rxjs/operators';

/**
 * Options for deployment requests
 */
export interface DeployOptions {
  isPrivate?: boolean;
  description?: string;
  includeDevContainer?: boolean;
  serverName?: string;
}

/**
 * URLs returned from deployment
 */
export interface DeploymentUrls {
  repository?: string;
  gist?: string;
  gistRaw?: string;
  codespace?: string;
  clone?: string;
  enterprise?: string;
}

/**
 * Validation status for deployed MCP servers
 */
export type ValidationStatus = 'pending' | 'running' | 'passed' | 'failed' | 'skipped';

/**
 * Tool validation result
 */
export interface ToolValidationResult {
  toolName: string;
  success: boolean;
  error?: string;
  executionTime: number;
}

/**
 * Validation result details
 */
export interface ValidationResult {
  buildSuccess: boolean;
  buildDuration?: number;
  buildError?: string;
  toolResults: ToolValidationResult[];
  errors?: string[];
  source: 'local_docker' | 'github_actions' | 'manual';
}

/**
 * Validation response from API
 */
export interface ValidationResponse {
  success: boolean;
  deploymentId: string;
  validationStatus: ValidationStatus;
  message: string;
  result?: ValidationResult;
  validatedAt?: Date;
  toolsPassedCount?: number;
  toolsTestedCount?: number;
}

/**
 * Validation status response
 */
export interface ValidationStatusResponse {
  deploymentId: string;
  validationStatus: ValidationStatus;
  validatedAt?: Date;
  toolsPassedCount?: number;
  toolsTestedCount?: number;
  validationResults?: ValidationResult;
}

/**
 * Response from deployment API
 */
export interface DeploymentResponse {
  success: boolean;
  deploymentId?: string;
  type?: 'gist' | 'repo' | 'enterprise' | 'none';
  urls?: DeploymentUrls;
  error?: string;
  errorCode?: string;
  // Validation fields
  validationStatus?: ValidationStatus;
  validatedAt?: Date;
  toolsPassedCount?: number;
  toolsTestedCount?: number;
  // Tier/usage limit fields
  currentUsage?: number;
  limit?: number;
  currentTier?: string;
  requiredTier?: string;
  upgradeUrl?: string;
}

/**
 * Request body for deployment
 */
interface DeployRequest {
  conversationId: string;
  options?: DeployOptions;
}

@Injectable({
  providedIn: 'root'
})
export class DeploymentService {
  private readonly baseUrl = 'http://localhost:3000/api/deploy';
  private readonly validationUrl = 'http://localhost:3000/api/validation';

  constructor(private http: HttpClient) {}

  /**
   * Deploy generated MCP server to GitHub repository
   */
  deployToGitHub(conversationId: string, options?: DeployOptions): Observable<DeploymentResponse> {
    const request: DeployRequest = {
      conversationId,
      options: options || {
        isPrivate: true,
        description: 'MCP server generated by MCP Everything',
        includeDevContainer: true
      }
    };

    return this.http.post<DeploymentResponse>(`${this.baseUrl}/github`, request).pipe(
      map(response => this.transformResponse(response)),
      catchError(error => this.handleError(error, 'deployToGitHub'))
    );
  }

  /**
   * Deploy generated MCP server to GitHub Gist
   */
  deployToGist(conversationId: string, options?: DeployOptions): Observable<DeploymentResponse> {
    const request: DeployRequest = {
      conversationId,
      options: options || {
        isPrivate: true,
        description: 'MCP server generated by MCP Everything'
      }
    };

    return this.http.post<DeploymentResponse>(`${this.baseUrl}/gist`, request).pipe(
      map(response => this.transformResponse(response)),
      catchError(error => this.handleError(error, 'deployToGist'))
    );
  }

  /**
   * Get deployment status for a conversation
   */
  getDeploymentStatus(conversationId: string): Observable<DeploymentResponse[]> {
    return this.http.get<{ deployments: DeploymentResponse[] }>(
      `${this.baseUrl}/${conversationId}/status`
    ).pipe(
      map(response => response.deployments || []),
      catchError(error => this.handleError(error, 'getDeploymentStatus'))
    );
  }

  /**
   * Retry a failed deployment
   */
  retryDeployment(conversationId: string): Observable<DeploymentResponse> {
    return this.http.post<DeploymentResponse>(
      `${this.baseUrl}/${conversationId}/retry`,
      {}
    ).pipe(
      map(response => this.transformResponse(response)),
      catchError(error => this.handleError(error, 'retryDeployment'))
    );
  }

  /**
   * Trigger validation for a deployment
   */
  validateDeployment(deploymentId: string, forceRevalidate = false): Observable<ValidationResponse> {
    return this.http.post<ValidationResponse>(
      `${this.validationUrl}/${deploymentId}/validate`,
      { forceRevalidate }
    ).pipe(
      catchError(error => this.handleError(error, 'validateDeployment'))
    );
  }

  /**
   * Get validation status for a deployment
   */
  getValidationStatus(deploymentId: string): Observable<ValidationStatusResponse> {
    return this.http.get<ValidationStatusResponse>(
      `${this.validationUrl}/${deploymentId}/status`
    ).pipe(
      catchError(error => this.handleError(error, 'getValidationStatus'))
    );
  }

  /**
   * Poll GitHub Actions for validation results
   */
  pollGitHubActionsValidation(deploymentId: string): Observable<ValidationResponse> {
    return this.http.post<ValidationResponse>(
      `${this.validationUrl}/${deploymentId}/poll-github`,
      {}
    ).pipe(
      catchError(error => this.handleError(error, 'pollGitHubActionsValidation'))
    );
  }

  /**
   * Transform API response to ensure consistent format
   */
  private transformResponse(response: DeploymentResponse): DeploymentResponse {
    return {
      ...response,
      urls: response.urls || {}
    };
  }

  /**
   * Handle HTTP errors
   */
  private handleError(error: HttpErrorResponse, operation: string): Observable<never> {
    console.error(`${operation} failed:`, error);

    let errorMessage = 'An unexpected error occurred';
    let errorCode: string | undefined;
    let tierErrorData: Partial<DeploymentResponse> = {};

    if (error.error instanceof ErrorEvent) {
      // Client-side error
      errorMessage = error.error.message;
    } else if (error.error?.errorCode) {
      // Tier/usage limit error from backend
      errorCode = error.error.errorCode;
      errorMessage = error.error.error || error.error.message;
      tierErrorData = {
        currentUsage: error.error.currentUsage,
        limit: error.error.limit,
        currentTier: error.error.currentTier,
        requiredTier: error.error.requiredTier,
        upgradeUrl: error.error.upgradeUrl,
      };
    } else if (error.error?.error) {
      // Backend error with message
      errorMessage = error.error.error;
    } else if (error.error?.message) {
      // Alternative backend error format
      errorMessage = error.error.message;
    } else if (error.status === 404) {
      errorMessage = 'Conversation not found. Please ensure the MCP server was generated first.';
    } else if (error.status === 429) {
      errorMessage = 'Too many requests. Please wait a moment before trying again.';
    } else if (error.status === 500) {
      errorMessage = 'Server error during deployment. Please try again.';
    }

    return throwError(() => ({
      success: false,
      error: errorMessage,
      errorCode,
      ...tierErrorData
    } as DeploymentResponse));
  }

  /**
   * Check if a deployment error is a usage limit error
   */
  isUsageLimitError(response: DeploymentResponse): boolean {
    return response.errorCode === 'LIMIT_EXCEEDED';
  }

  /**
   * Check if a deployment error is a tier restriction error
   */
  isTierRestrictionError(response: DeploymentResponse): boolean {
    return response.errorCode === 'TIER_RESTRICTION';
  }
}
